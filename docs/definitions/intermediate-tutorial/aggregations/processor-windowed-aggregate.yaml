streams:
  sensor_temperatures:
    topic: sensor_temperatures
    keyType: string
    valueType: double

functions:
  init_stats:
    type: initializer
    code: |
      stats = {
        "count": 0,
        "sum": 0.0,
        "min": None,
        "max": None
      }
    expression: stats
    resultType: json

  update_stats:
    type: aggregator
    code: |
      # Update count and sum
      aggregatedValue["count"] += 1
      aggregatedValue["sum"] += value
      
      # Update min/max
      if aggregatedValue["min"] is None or value < aggregatedValue["min"]:
        aggregatedValue["min"] = value
      if aggregatedValue["max"] is None or value > aggregatedValue["max"]:
        aggregatedValue["max"] = value
      
      # Calculate average
      aggregatedValue["avg"] = round(aggregatedValue["sum"] / aggregatedValue["count"], 2)
      
      result = aggregatedValue
    expression: result
    resultType: json

  log_window_stats:
    type: forEach
    code: |
      # Extract window information from the key
      window_start = key["startTime"]
      window_end = key["endTime"]
      sensor_id = key["key"]
      
      log.info("Sensor {} | Window [{} - {}] | Stats: {} readings, avg: {}C, min: {}C, max: {}C", 
               sensor_id, window_start, window_end, 
               value["count"], value["avg"], value["min"], value["max"])

pipelines:
  windowed_temperature_stats:
    from: sensor_temperatures
    via:
      - type: groupByKey
      - type: windowByTime
        windowType: tumbling
        duration: 30s
        grace: 5s
      - type: aggregate
        store:
          type: window
          windowSize: 30s
          retention: 2m
          caching: false
        initializer: init_stats
        aggregator: update_stats
      - type: toStream
    forEach: log_window_stats