# Processor demonstrating dead letter queue pattern using separate pipelines

streams:
  mixed_messages:
    topic: mixed_messages
    keyType: string
    valueType: json

functions:
  validate_message:
    type: predicate
    code: |
      # Validate JSON message structure and business rules
      
      # Check message type
      message_type = value.get("message_type")
      if message_type != "ORDER":
        log.warn("Invalid message type '{}' for {}", message_type, key)
        return False
      
      # Check required fields
      order_id = value.get("order_id")
      if not order_id:
        log.warn("Missing order_id in message {}", key)
        return False
      
      # Check amount field existence and type
      amount = value.get("amount")
      if amount is None:
        log.warn("Missing amount field in message {}", key)
        return False
      
      # Validate amount is numeric and positive
      try:
        amount_value = float(amount)
        if amount_value <= 0:
          log.warn("Invalid amount {} for message {}", amount_value, key)
          return False
      except (ValueError, TypeError):
        log.warn("Non-numeric amount '{}' for message {}", amount, key)
        return False
      
      # Check timestamp
      timestamp = value.get("timestamp")
      if not timestamp:
        log.warn("Missing timestamp in message {}", key)
        return False
      
      # Check customer_id
      customer_id = value.get("customer_id")
      if not customer_id:
        log.warn("Missing customer_id in message {}", key)
        return False
      
      return True
    expression: result

  process_valid_message:
    type: valueTransformer
    globalCode: |
      import time
    code: |
      # Process valid JSON orders
      order_id = value.get("order_id")
      amount = float(value.get("amount"))
      customer_id = value.get("customer_id")
      product_id = value.get("product_id", "unknown")
      timestamp = value.get("timestamp")
      current_time = int(time.time() * 1000)
      
      # Apply business logic (e.g., add processing fee)
      processing_fee = amount * 0.02  # 2% processing fee
      total = amount + processing_fee
      
      # Create structured JSON response
      processed_order = {
        "status": "PROCESSED",
        "order_id": order_id,
        "customer_id": customer_id,
        "product_id": product_id,
        "original_amount": amount,
        "processing_fee": round(processing_fee, 2),
        "total_amount": round(total, 2),
        "original_timestamp": timestamp,
        "processed_timestamp": current_time,
        "processing_time": current_time - timestamp,
        "metadata": value.get("metadata", {})
      }
      
      log.info("Processed order {}: ${:.2f} total", order_id, total)
      return processed_order
      
    expression: result
    resultType: json

  create_dlq_entry:
    type: valueTransformer
    globalCode: |
      import time
      import json
    code: |
      # Create structured dead letter queue entry with error metadata
      error_time = int(time.time() * 1000)
      original_timestamp = value.get("timestamp", 0)
      
      # Determine error reason based on message content
      error_reason = "unknown_error"
      if value.get("amount") is None:
        error_reason = "missing_amount_field"
      elif value.get("amount") == "NOT_A_NUMBER":
        error_reason = "invalid_amount_type"
      elif isinstance(value.get("amount"), (int, float)) and value.get("amount") <= 0:
        error_reason = "negative_amount"
      elif not value.get("customer_id"):
        error_reason = "missing_customer_id"
      elif not value.get("order_id"):
        error_reason = "missing_order_id"
      
      dlq_entry = {
        "status": "DLQ_ENTRY",
        "original_key": key,
        "original_message": value,
        "error_reason": error_reason,
        "failed_timestamp": error_time,
        "original_timestamp": original_timestamp,
        "time_to_failure": error_time - original_timestamp if original_timestamp else 0,
        "dlq_metadata": {
          "processor": "dead_letter_queue",
          "version": "1.0",
          "retry_recommended": error_reason not in ["invalid_amount_type", "negative_amount"]
        }
      }
      
      log.error("Sending to DLQ - Reason: {} for key: {}", error_reason, key)
      return dlq_entry
      
    expression: result
    resultType: json

pipelines:
  # Process valid messages
  valid_message_pipeline:
    from: mixed_messages
    via:
      - type: filter
        if: validate_message
      - type: mapValues
        mapper: process_valid_message
    to:
      topic: processed_messages
      keyType: string
      valueType: json

  # Route invalid messages to DLQ
  dlq_pipeline:
    from: mixed_messages
    via:
      - type: filterNot
        if: validate_message
      - type: mapValues
        mapper: create_dlq_entry
    to:
      topic: dlq_messages
      keyType: string
      valueType: json