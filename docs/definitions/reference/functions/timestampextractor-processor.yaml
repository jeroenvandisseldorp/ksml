streams:
  events_input:
    topic: timestamped_events
    keyType: string
    valueType: json
    # Configure custom timestamp extraction
    timestampExtractor:
      code: |
        import time
        
        # Extract the record value
        value = record.value()
        
        if value is not None and "event_timestamp" in value:
          event_time = value.get("event_timestamp")
          if event_time and event_time > 0:
            log.debug("Using event timestamp {} for record {}", 
                     event_time, value.get("event_id"))
            return event_time
        
        # Fall back to record timestamp if no valid event timestamp
        record_timestamp = record.timestamp()
        if record_timestamp > 0:
          log.debug("Using record timestamp {} for record {}", 
                   record_timestamp, value.get("event_id") if value else "unknown")
          return record_timestamp
          
        # Last resort: use current time
        current_time = int(time.time() * 1000)
        log.warn("No valid timestamp found, using current time {} for record {}", 
                current_time, value.get("event_id") if value else "unknown")
        return current_time
        
  ordered_events:
    topic: time_ordered_events
    keyType: string
    valueType: json

functions:
  log_timestamp_info:
    type: forEach
    code: |
      event_time = value.get("event_timestamp") if value else 0
      delay = value.get("processing_delay", 0) if value else 0
      
      log.info("Event processed in time order: {} (event_time={}, delay={}s)", 
               key, event_time, delay)

pipelines:
  process_with_event_time:
    from: events_input
    via:
      - type: peek
        forEach: log_timestamp_info
    to: ordered_events